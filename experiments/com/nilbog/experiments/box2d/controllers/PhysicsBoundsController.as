package com.nilbog.experiments.box2d.controllers {	import com.nilbog.experiments.box2d.actors.CircleFace;	import com.nilbog.experiments.box2d.actors.RandomConvexShape;	import com.nilbog.experiments.box2d.actors.SquareFace;	import com.nilbog.experiments.box2d.actors.StaticWall;	import com.nilbog.physics.actors.PhysicsActor;	import com.nilbog.physics.controllers.PhysicsController;	import com.nilbog.physics.events.PhysicsBoundaryEvent;	import com.nilbog.physics.models.PhysicsModel;	import com.nilbog.physics.views.PhysicsView;	import com.nilbog.random.RNG;	import com.nilbog.util.displayobject.FrameUpdater;	import com.nilbog.util.displayobject.UpdateEvent;	import flash.geom.Point;	/**	 * Controller that keeps a set number of particles within bounds at all	 * times.	 * 	 * @author jmhnilbog	 */	public class PhysicsBoundsController extends PhysicsController 	{		private static const PARTICLE_COUNT:uint = 3;				private var oobActors:Array = [];				public function PhysicsBoundsController(m:PhysicsModel, v:PhysicsView = null)		{			super( m, v );						log.trace("%s(%s)", "PhysicsBoundsController", arguments.join(", "));						FrameUpdater.instance.addEventListener(UpdateEvent.UPDATE, onTick);						generateGround();		}				public function onOutOfBounds( event:PhysicsBoundaryEvent ) :void		{			log.trace("%s(%s)", "onOutOfBounds", arguments.join(", "));						// flag an actor as no good			oobActors.push( event.actor );		}				private function onTick( event:UpdateEvent ) :void		{			log.trace("%s(%s)", "onTick", arguments.join(", "));			var m:PhysicsModel = getModel() as PhysicsModel;			while( oobActors.length != 0)			{				var actor:PhysicsActor = oobActors.pop();				log.info("Removing: %s", actor);				m.removeActor(actor);			}						for (var i:uint = m.actorCount; i < PARTICLE_COUNT; i++)			{				generateParticle();				//generateRagdoll();			}		}				private function generateRagdoll() :void		{//			var m:PhysicsModel = getModel() as PhysicsModel;//			//			//Material.FLESH.density = 0;//			var head:PhysicsActor = new PhysicsActor(new Vector.<Physics2DShape>([new Circle(.3)]), Material.FLESH);//			//			var torsoShape:Rectangle = new Rectangle( -.5, -.15, 1, .3 );//			var torsoShapes:Vector.<Physics2DShape> = new Vector.<Physics2DShape>([ torsoShape ]);//			var torsoTop:PhysicsActor = new PhysicsActor( torsoShapes, Material.FLESH);//			var torsoMid:PhysicsActor = new PhysicsActor( torsoShapes, Material.FLESH);//			var torsoBottom:PhysicsActor = new PhysicsActor( torsoShapes, Material.FLESH);//			//			var upperArmShape:Rectangle = new Rectangle( -.3, -.1, .6, .2 );//			var upperArmShapes:Vector.<Physics2DShape> = new Vector.<Physics2DShape>([ upperArmShape ]);//			var leftUpperArm:PhysicsActor = new PhysicsActor( upperArmShapes, Material.FLESH);//			var rightUpperArm:PhysicsActor = new PhysicsActor( upperArmShapes, Material.FLESH);//			//			var lowerArmShape:Array = [ new Point(-.26, -.1), new Point(.26, -.1), new Point(.26, .1), new Point(-.26, .1)];//			var lowerArmShapes:Vector.<Physics2DShape> = new Vector.<Physics2DShape>([ lowerArmShape ]);//			var leftLowerArm:PhysicsActor = new PhysicsActor( lowerArmShapes, Material.FLESH);//			var rightLowerArm:PhysicsActor = new PhysicsActor( lowerArmShapes, Material.FLESH);//			//			var upperLegShape:Array = [ new Point(-.125, -.36), new Point(.125, -.36), new Point(.125, .36), new Point(-.125, .36)];//			var upperLegShapes:Vector.<Physics2DShape> = new Vector.<Physics2DShape>([ upperLegShape ]);//			var leftUpperLeg:PhysicsActor = new PhysicsActor( upperLegShapes, Material.FLESH);//			var rightUpperLeg:PhysicsActor = new PhysicsActor( upperLegShapes, Material.FLESH);//			//			var lowerLegShape:Array = [ new Point(-.1, -.33), new Point(.1, -.33), new Point(.1, .33), new Point(-.1, .33)];//			var lowerLegShapes:Vector.<Physics2DShape> = new Vector.<Physics2DShape>([ lowerLegShape ]);//			var leftLowerLeg:PhysicsActor = new PhysicsActor( lowerLegShapes, Material.FLESH);//			var rightLowerLeg:PhysicsActor = new PhysicsActor( lowerLegShapes, Material.FLESH);//			//			// position our actors relative to each other//			head.position = new Point( RNG.random() * m.worldSize.width, 0 );//			torsoTop.position = new Point( head.position.x, head.height/2 + .25 );//			torsoMid.position = new Point( torsoTop.position.x, torsoTop.position.y + torsoTop.height );//			torsoBottom.position = new Point( torsoMid.position.x, torsoMid.position.y + torsoMid.height );//			leftUpperArm.position = new Point( torsoTop.position.x - torsoTop.width/2, torsoTop.position.y - torsoTop.height/2 + leftUpperArm.height/2 );//			rightUpperArm.position = new Point( torsoTop.position.x + torsoTop.width/2, torsoTop.position.y - torsoTop.height/2 + leftUpperArm.height/2 );////			leftLowerArm.position = new Point( leftUpperArm.position.x, leftUpperArm.position.y + leftUpperArm.height/2 );////			rightLowerArm.position = new Point( rightUpperArm.position.x, rightUpperArm.position.y + rightUpperArm.height/2 );////			leftUpperLeg.position = new Point( torsoBottom.position.x - torsoBottom.width/2, torsoBottom.position.y + torsoBottom.height/2);////			rightUpperLeg.position = new Point( torsoBottom.position.x + torsoBottom.width/2, torsoBottom.position.y + torsoBottom.height/2);////			//			// add them to the model in order to populate the 'body' fields of the PhysicsActors//			m.addActor(head);//			m.addActor(torsoTop);////			model.addActor(torsoMid);////			model.addActor(torsoBottom);////			model.addActor(leftUpperArm);////			model.addActor(rightUpperArm);////			model.addActor(leftLowerArm);////			model.addActor(rightLowerArm);////			model.addActor(leftUpperLeg);////			model.addActor(rightUpperLeg);////			model.addActor(leftLowerLeg);////			model.addActor(rightLowerLeg);////			log.info("Head at: %s, %s", head.position.x, head.position.y);//			log.info("Head size: %s x %s", head.width, head.height);//			//			log.info("Torso at: %s, %s", torsoTop.position.x, torsoTop.position.y);//			log.info("Torso size: %s x %s", torsoTop.width, torsoTop.height);//			//			var torsoTopY:Number = torsoTop.position.y - torsoTop.height/2;//			var headBottomY:Number = head.position.y + head.height/2;//			var neckCenterY:Number = (torsoTopY - headBottomY) / 2 + headBottomY;//			var neck:Point = new Point( head.position.x, neckCenterY );//			log.info("Joint connects head and torso at point: %s, %s", neck.x, neck.y);//			//			// add joints////			m.addRevoluteJoint(head, torsoTop, neck, degreesToRadians(-40), degreesToRadians(40));//				////			model.addJoint(JointType.REVOLUTE, torsoTop, torsoMid,////				new Point(torsoTop.position.x, torsoMid.position.y - torsoTop.position.y),////				degreesToRadians(-15), degreesToRadians(15));////				////			model.addJoint(JointType.REVOLUTE, torsoMid, torsoBottom,////				new Point(torsoMid.position.x, torsoBottom.position.y - torsoMid.position.y),////				degreesToRadians(-15), degreesToRadians(15));//				////			model.addJoint(JointType.REVOLUTE, torsoTop, leftUpperArm, ////				new Point(leftUpperArm.position.x - torsoTop.position.x, torsoTop.position.y), ////				degreesToRadians(-85), degreesToRadians(130));////				////			model.addJoint(JointType.REVOLUTE, torsoTop, rightUpperArm, ////				new Point(rightUpperArm.position.x + torsoTop.position.x, torsoTop.position.y), ////				degreesToRadians(-85), degreesToRadians(130));		}				private function generateGround() :void		{			log.trace("%s(%s)", "generateGround", arguments.join(", "));						var m:PhysicsModel = getModel() as PhysicsModel;						var position:Point = new Point( 25, m.worldSize.height - .5 );			m.addActor( new StaticWall( 50, 1, position, .1) );		}				private function generateParticle() :void		{			log.trace("%s(%s)", "generateParticle", arguments.join(", "));						var m:PhysicsModel = getModel() as PhysicsModel;						//var squid:Squid = new Squid(RNG.random( ) * m.worldSize.width, RNG.random() * 2 + 1);			//m.addMachine( squid );			//			var random:Number = RNG.random();//			if (random < .3)//			{//				generateSquareParticle();//			}//			else if (random < .6)//			{//				generateCircularParticle();//			}//			else//			{//				generateRandomParticle();//			}		}				private function generateSquareParticle() :void		{			log.trace("%s(%s)", "generateSquareParticle", arguments.join(", "));						var m:PhysicsModel = getModel() as PhysicsModel;						var side:Number = RNG.random() * 5 + 1;			var position:Point = new Point( RNG.random() * m.worldSize.width, RNG.random() * 10 );						m.addActor( new SquareFace( side, side, position) );		}				private function generateCircularParticle() :void		{			log.trace("%s(%s)", "generateCircularParticle", arguments.join(", "));						var m:PhysicsModel = getModel() as PhysicsModel;						var radius:Number = RNG.random() * 5 + 1;			var position:Point = new Point( RNG.random() * m.worldSize.width, RNG.random() * 10 );			m.addActor( new CircleFace(radius, position) );		}				private function generateRandomParticle() :void		{			log.trace("%s(%s)", "generateRandomParticle", arguments.join(", "));						var m:PhysicsModel = getModel() as PhysicsModel;						var position:Point = new Point( RNG.random() * m.worldSize.width, RNG.random() * 10 );			m.addActor(new RandomConvexShape(position));		}	}}