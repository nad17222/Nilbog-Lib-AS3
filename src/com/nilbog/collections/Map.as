package com.nilbog.collections {	import com.nilbog.collections.ISet;		import flash.utils.Dictionary;		/**	 * @author markhawley	 */	public class Map implements IMap	{		internal var impl:Dictionary;				protected var keyType:Class;		protected var valueType:Class;				/**		 * Constructor.		 */		public function Map(obj:*=null, kType:Class=null, valueType:Class=null)		{			keyType = kType;			this.valueType = valueType;						if (obj is Dictionary)			{				impl = obj as Dictionary;			}			else			{				impl = new Dictionary();				if (obj)				{					for (var i:String in obj)					{						put( i, obj[i]);					}				}			}		}				public function containsKey(key:*):Boolean		{			var keys:ISet = keySet();			return keys.contains(key);		}				public function containsValue(value:*):Boolean		{			var values:IList = values();			return values.contains(value);		}				public function entrySet():ISet		{			var pairs:ISet = new Set( null, MapEntry );			for (var k:* in impl)			{				pairs.add( new MapEntry( k, impl[k]));			}			return pairs;		}				public function getAt(key:*):*		{			return impl[key];		}				public function keySet():ISet		{			var keys:ISet = new Set( null, keyType );			for (var k:* in impl)			{				keys.add( k );			}			return keys;		}				public function put(key:*, value:*):*		{			if (keyType != null && !(key is keyType))			{				throw new TypeError("Cannot put key '" + key + "' into " + 					"map: bad type.");			}			if (valueType != null && !(value is valueType))			{				throw new TypeError("Cannot put value '" + value + "' into " + 					"map: bad type.");			}						var old:* = getAt(key);			impl[key] = value;			return old;		}				public function values():IList		{			var vals:IList = new List( null, valueType );			for (var k:* in impl)			{				vals.add( impl[k] );			}			return vals;		}				public function size():int		{			return keySet().size( );		}				public function isEmpty():Boolean		{			return size() != 0;		}	}}