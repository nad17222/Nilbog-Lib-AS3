package com.nilbog.physics.actors {	import Box2D.Common.Math.b2Vec2;	import Box2D.Dynamics.b2Body;	import com.nilbog.physics.materials.Material;	import com.nilbog.physics.shapes.Physics2DShape;	import com.nilbog.util.IDestroyable;	import com.nilbog.util.geometry.GeometryUtil;	import com.nilbog.util.geometry.IShape;	import flash.display.DisplayObject;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * Defines an actor in a physics simulation.	 * 	 * @author jmhnilbog	 */	public class PhysicsActor implements IDestroyable	{		public var shapeList:Vector.<Physics2DShape>;		public var graphic:DisplayObject;		public var body:b2Body;				private var _material:Material;				private var _rotation:Number = 0;		private const _position:Point = new Point(0, 0);				private var _cachedHeight:Number;		private var _cachedWidth:Number;				/**		 * Constructor.		 * 		 * @param	shape		Object		 * @param	material	Material (defaults to the default Material, a 		 * 						'perfect', static material.)		 * @param	position	Point (defaults to 0, 0)		 * @param	rotation	Number (defaults to 0)		 * @param	graphic		DisplayObject (defaults to null)		 * @param	body		b2Body	(defaults to null. Must normally be		 * 						populated by adding it to the model.)		 */		public function PhysicsActor		(			shapeList:Vector.<Physics2DShape>,			material:Material=null,			position:Point=null,			rotation:Number=0,			graphic:DisplayObject=null,			body:b2Body=null		)		{			this.shapeList = shapeList;						if (null == material)			{				material = Material.NULL_MATERIAL;			}						this.material = material;						this.graphic = graphic;			this.body = body;						this.rotation = rotation;						if (position != null)			{				this.position = position;			}		}		/**		 * Returns the actor's maximum height, in meters.		 * 		 * @return	Number		 */		public function get height() :Number		{			if (isNaN(_cachedHeight))			{				var max:Number = Number.NEGATIVE_INFINITY;				var min:Number = Number.POSITIVE_INFINITY;								for (var i:uint=0; i < shapeList.length; i++)				{					var shape:IShape = shapeList[i];					var bounds:Rectangle = GeometryUtil.getBoundingBox(shape);					max = Math.max( bounds.y + bounds.height, max );					min = Math.min( bounds.y, min );				}				_cachedHeight = max - min;			}			return _cachedHeight;		}				/**		 * Returns the actor's maximum width, in meters.		 * 		 * @return	Number		 */		public function get width() :Number		{			if (isNaN(_cachedWidth))			{				var max:Number = Number.NEGATIVE_INFINITY;				var min:Number = Number.POSITIVE_INFINITY;								for (var i:uint=0; i < shapeList.length; i++)				{					var shape:IShape = shapeList[i];					var bounds:Rectangle = GeometryUtil.getBoundingBox(shape);					max = Math.max( bounds.x + bounds.width, max );					min = Math.min( bounds.x, min );				}				_cachedWidth = max - min;			}						return _cachedWidth;		}		/**		 * Returns the position of the actor in the simulation (in meters)		 * 		 * @return Point		 */		public function get position() :Point		{			if (null == body)			{				return _position;			}			else			{				var vec:b2Vec2 = body.GetPosition();				_position.x = vec.x;				_position.y = vec.y;				return _position;			}		}				/**		 * Sets the position of the actor in the simulation (in meters)		 * 		 * @param Point		 */		public function set position(p:Point) :void		{			_position.x = p.x;			_position.y = p.y;						if (null != body)			{				var vec:b2Vec2 = new b2Vec2(_position.x, _position.y);				body.SetXForm(vec, _rotation);			}		}				/**		 * Gets the rotation of the actor in the simulation (in radians)		 * 		 * @return Number		 */		public function get rotation() :Number		{			if (null == body)			{				return _rotation;			}			else			{				var r:Number = body.GetAngle();				_rotation = r;				return _rotation;			}		}				/**		 * Sets the rotation of the actor in the simulation (in radians)		 * 		 * @param	v	Number		 */		public function set rotation(v:Number) :void		{			_rotation = v;						if (null != body)			{				var vec:b2Vec2 = new b2Vec2(_position.x, _position.y);				body.SetXForm(vec, _rotation);			}		}				public function set material(v:Material) :void		{			_material = v;		}		public function get material():Material		{			return new Material(_material.density, _material.restitution, _material.friction);		}		public function destroy():void		{			shapeList = null;						material= null;			graphic=null;			body=null; 		}				public function isDestroyed():Boolean		{			return null == shapeList;		}	}}