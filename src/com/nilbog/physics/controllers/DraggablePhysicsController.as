package com.nilbog.physics.controllers {	import com.nilbog.physics.actors.PhysicsActor;	import com.nilbog.physics.controllers.PhysicsController;	import com.nilbog.physics.events.PhysicsDestructionEvent;	import com.nilbog.physics.joints.MouseJoint;	import com.nilbog.physics.models.PhysicsModel;	import com.nilbog.physics.views.PhysicsView;	import com.nilbog.util.MouseManager;	import com.nilbog.util.displayobject.FrameUpdater;	import com.nilbog.util.displayobject.UpdateEvent;	import flash.geom.Point;	/**	 * Controller to handle mouse events in a physics simulation. Allows for	 * grabbing and moving items by default.	 * 	 * @author jmhnilbog	 */	public class DraggablePhysicsController extends PhysicsController	{		private static var mouseManager:MouseManager;			private static var mouseJoint:MouseJoint;		/**		 * Constructor.		 * 		 * @param	m	PhysicsModel		 * @param	v	PhysicsView (mandatory) This view must be added to the		 * 				stage before this class can do anything.		 */		public function DraggablePhysicsController(m:PhysicsModel, v:PhysicsView)		{			super( m, v );						if (!(m.eventFlags & PhysicsModel.DISPATCH_DESTRUCTION_EVENTS))			{				log.warn("Use of the PhysicsModel.DISPATCH_DESTRUCTION_EVENTS flag" +				" is highly recommended when using this controller.");			}						if (mouseManager == null)			{				mouseManager = new MouseManager(v);			}			FrameUpdater.instance.addEventListener(UpdateEvent.UPDATE, onUpdate);		}				/**		 * Called whenever a joint is about to be destroyed. Cleans up if the		 * mouseJoint is about to be destroyed. (If a user is dragging an		 * actor and it leaves the bounds of the simulation, it will be		 * destroyed, invalidating the mouse joint unless this is accounted for.)		 */		public function onJointDestroyed(event:PhysicsDestructionEvent) :void		{			log.trace("%s(%s)", "onJointDestroyed", arguments.join(", "));						if (mouseJoint && mouseJoint.joint == event.joint)			{				mouseJoint.destroy();				mouseJoint = null;				mouseManager.mouseDown = false;								var m:PhysicsModel = getModel() as PhysicsModel;							if (!(m.eventFlags & PhysicsModel.DISPATCH_DESTRUCTION_EVENTS))				{					log.error("I warned you. You need to use the " +					"PhysicsModel.DISPATCH_DESTRUCTION_EVENTS flag to avoid these " +					"errors.");				}			}		}				/**		 * Called on each frame update. Handles dragging of physics bodies.		 * 		 * @param	event	UpdateEvent		 */		private function onUpdate( event:UpdateEvent ) :void		{			var v:PhysicsView = getView() as PhysicsView;			var m:PhysicsModel = getModel() as PhysicsModel;						// a drag is starting this frame?			if (mouseManager.mouseDown && !mouseJoint)			{				var clickedAt:Point = new Point( mouseManager.mouseDownPoint.x/v.scale, mouseManager.mouseDownPoint.y/v.scale );				var actor:PhysicsActor = m.getActorAtPoint(clickedAt);				if (null != actor)				{					log.info("Starting mouse drag. Dragging: %s", actor);					mouseJoint = new MouseJoint(actor, clickedAt);					m.addJoint(mouseJoint);				}			}						// a drag just ended this frame?			if (!mouseManager.mouseDown)			{				if (mouseJoint)				{					log.info("Ending mouse drag. Removing joint: %s", mouseJoint);					m.removeJoint( mouseJoint );					mouseJoint.destroy();					mouseJoint = null;				}			}						// a drag is ongoing?			if (mouseJoint)			{				log.debug("Moving mouse target...");				mouseJoint.setTarget( mouseManager.mouseLocation.x/v.scale, mouseManager.mouseLocation.y/v.scale );			}		}	}}