package com.nilbog.physics.controllers {	import com.nilbog.animation.Animation;	import com.nilbog.log.LogLevel;	import com.nilbog.physics.actors.PhysicsActor;	import com.nilbog.physics.controllers.PhysicsController;	import com.nilbog.physics.materials.Material;	import com.nilbog.physics.models.PhysicsModel;	import com.nilbog.physics.shapes.Physics2DShape;	import com.nilbog.physics.shapes.PhysicsPolygon;	import com.nilbog.physics.views.PhysicsView;	import com.nilbog.util.MouseManager;	import com.nilbog.util.displayobject.FrameUpdater;	import com.nilbog.util.displayobject.UpdateEvent;	import flash.display.Shape;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * Controller to handle mouse events in a physics simulation. Allows for	 * grabbing and moving items by default.	 * 	 * @author jmhnilbog	 */	public class ShapeDrawingController extends PhysicsController	{		private var mouseManager:MouseManager;				private var drawing:Boolean = false;		private var ignoring:Boolean = false;		private var scratchPad:Shape = new Shape();		/**		 * Constructor.		 * 		 * @param	m	PhysicsModel		 * @param	v	PhysicsView (mandatory) This view must be added to the		 * 				stage before this class can do anything.		 */		public function ShapeDrawingController(m:PhysicsModel, v:PhysicsView)		{			super( m, v );			log.minimumLevel = LogLevel.WARN;						if (!(m.eventFlags & PhysicsModel.DISPATCH_DESTRUCTION_EVENTS))			{				log.warn("Use of the PhysicsModel.DISPATCH_DESTRUCTION_EVENTS flag" +				" is highly recommended when using this controller.");			}						if (mouseManager == null)			{				mouseManager = new MouseManager(v);			}						FrameUpdater.instance.addEventListener(UpdateEvent.UPDATE, onUpdate);						v.addChild(scratchPad);		}				private function onMousePressed() :void		{			log.info("%s(%s)", "onMousePressed", arguments.join(", "));			var v:PhysicsView = getView() as PhysicsView;			var m:PhysicsModel = getModel() as PhysicsModel;						var dragRect:Rectangle = mouseManager.dragRegion;			// did an actor get clicked?			var physicsClickPoint:Point = new Point( mouseManager.mouseDownPoint.x/v.scale, mouseManager.mouseDownPoint.y/v.scale);			if (null == m.getActorAtPoint( physicsClickPoint ))			{				// clicked empty space -- start drawing				drawing = true;				ignoring = false;				scratchPad.x = mouseManager.mouseDownPoint.x;				scratchPad.y = mouseManager.mouseDownPoint.y;				Animation.animator.to( scratchPad, 0, { alpha: 1 });			}			else			{				// clicked an existing body. Ignore until the next mouse down				ignoring = true;				drawing = true;			}		}				private function onMouseReleased() :void		{			log.info("%s(%s)", "onMouseReleased", arguments.join(", "));						if (ignoring)			{				ignoring = false;				drawing = false;				return;			}						drawing = false;						var newActor:PhysicsActor = generateDrawnActor();			var m:PhysicsModel = getModel() as PhysicsModel;			m.addActor(newActor);						Animation.animator.to( scratchPad, .5, { alpha: 0 });		}				private function generateDrawnActor() :PhysicsActor		{			log.info("%s(%s)", "generateDrawnActor", arguments.join(", "));						var dragRect:Rectangle = mouseManager.dragRegion;			drawing = false;						var v:PhysicsView = getView() as PhysicsView;						var w:Number = dragRect.width/v.scale;			var h:Number = dragRect.height/v.scale;			var tl:Point = new Point(0, 0);			var tr:Point = new Point(w, 0);			var br:Point = new Point(w, h);			var bl:Point = new Point(0, h);			var poly:PhysicsPolygon = new PhysicsPolygon( Vector.<Point>([tl, tr, br, bl]));						var box:PhysicsActor = new PhysicsActor			( 				Vector.<Physics2DShape>([poly]), 				Material.STEEL, 				new Point( dragRect.left/v.scale, dragRect.top/v.scale)			);						return box;		}//		private function generateDrawnActor() :PhysicsActor//		{//			log.info("%s(%s)", "generateDrawnActor", arguments.join(", "));//			//			var dragRect:Rectangle = mouseManager.dragRegion;//			drawing = false;//			//			var v:PhysicsView = getView() as PhysicsView;//			//			var radius:Number = Math.min(dragRect.width, dragRect.height)/v.scale;//			var center:Point = new Point(dragRect.width/2, dragRect.height/2);//			var planetoid:PhysicsActor = new RandomConvexShape(center, radius);//			//			return planetoid;//		}		private function onMouseHeld() :void		{			log.info("%s(%s)", "onMouseHeld", arguments.join(", "));						if (ignoring)			{				return;			}			var dragRect:Rectangle = mouseManager.dragRegion;						scratchPad.graphics.clear();			scratchPad.graphics.lineStyle(1, 0xffffff, 1);			scratchPad.graphics.beginFill(0xff0000, .5);			scratchPad.graphics.drawRect(0, 0,  dragRect.width, dragRect.height);			scratchPad.graphics.endFill();						scratchPad.x = dragRect.x;			scratchPad.y = dragRect.y;		}				/**		 * Called on each frame update. Handles dragging of physics bodies.		 * 		 * @param	event	UpdateEvent		 */		private function onUpdate( event:UpdateEvent ) :void		{			log.info("%s/%s", mouseManager.mouseDown, drawing);						// did the mouse just get pressed?			if (mouseManager.mouseDown && !drawing)			{				onMousePressed();			}						// a drag just ended this frame?			if (!mouseManager.mouseDown && drawing)			{				onMouseReleased();			}						// a drag is ongoing?			if (mouseManager.mouseDown && drawing)			{					onMouseHeld();			}		}	}}