package com.nilbog.physics.shapes {	import com.nilbog.assertions.assert;	import com.nilbog.util.geometry.IShape;	import flash.display.DisplayObject;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * @author jmhnilbog	 */	public class Physics2DShape implements IShape	{		public var collisionGroup:int;		public var collisionCategory:uint;		public var collisionMask:uint;		public var isSensor:Boolean;		public var graphic:DisplayObject;				protected var shape:IShape;				public function Physics2DShape( graphic:DisplayObject=null, collisionGroup:int=0, collisionCategory:int=0x000f, collisionMask:int=0xffff, isSensor:Boolean=false)		{			this.graphic = graphic;			this.collisionGroup = collisionGroup;			this.collisionCategory = collisionCategory;			this.collisionMask = collisionMask;			this.isSensor = isSensor;		}				public function get center():Point		{			return shape.center;		}				public static function generateShapeFromWidthAndHeight( width:Number, height:Number ) :Physics2DShape		{			var w:Number = width/2;			var h:Number = height/2;						var points:Vector.<Point> = Vector.<Point>([ new Point( -w, -h ), new Point( w, -h), new Point( w, h), new Point( -w, h) ]);			return new PhysicsPolygon( points );		}						public static function generateShapeList( shape:Physics2DShape, ...other ) :Vector.<Physics2DShape>		{			var shapes:Vector.<Physics2DShape> = Vector.<Physics2DShape>([shape]);			for (var i:uint=0; i < other.length; i++)			{				var s:Physics2DShape = other[i] as Physics2DShape;				assert(s != null);				shapes.push(s);			}			return shapes;		}				public static function generateShapeFromRectangle( r:Rectangle ) :Physics2DShape		{			var tl:Point = r.topLeft;			var tr:Point = new Point( r.right, r.top );			var br:Point = r.bottomRight;			var bl:Point = new Point( r.left, r.bottom );			var points:Vector.<Point> = Vector.<Point>([ tl, tr, br, bl ]);						return new PhysicsPolygon( points );		}	}}