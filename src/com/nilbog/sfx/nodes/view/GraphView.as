package com.nilbog.sfx.nodes.view {	import com.nilbog.util.geometry.Vector2D;	import flash.geom.Point;	import com.nilbog.datastructures.graph.Edge;	import com.nilbog.datastructures.graph.Node;	import com.nilbog.log.LogLevel;	import com.nilbog.mvc.AbstractView;	import com.nilbog.mvc.IController;	import com.nilbog.mvc.IModel;	import com.nilbog.random.RNG;	import com.nilbog.sfx.nodes.model.GraphEdgeEvent;	import com.nilbog.sfx.nodes.model.GraphModel;	import com.nilbog.sfx.nodes.model.GraphNodeEvent;	import com.nilbog.util.IDestroyable;	import com.nilbog.util.displayobject.FrameUpdater;	import com.nilbog.util.displayobject.UpdateEvent;	import flash.display.DisplayObject;	/**	 * @author jmhnilbog	 */	public class GraphView extends AbstractView	{		public function GraphView(m:IModel, c:IController = null)		{			super( m, c );						log.minimumLevel = LogLevel.INFO;						m.addEventListener(GraphNodeEvent.NODE_ADDED, onNodeAdded);			m.addEventListener(GraphNodeEvent.NODE_REMOVED, onNodeRemoved);			m.addEventListener(GraphEdgeEvent.EDGE_ADDED, onEdgeAdded);			m.addEventListener(GraphEdgeEvent.EDGE_REMOVED, onEdgeRemoved);						FrameUpdater.instance.addEventListener(UpdateEvent.UPDATE, onUpdate);		}				private function onNodeAdded(event:GraphNodeEvent) :void		{			var n:NodeSprite = new NodeSprite( event.node );			//n.idealPosition.x = RNG.random() * 550 - 275;			//n.idealPosition.y = RNG.random() * 400 - 200;			//log.info("Adding node, wants to be at %s", n.idealPosition);			addChild(n);			onChange();			}				override public function destroy() :void		{			var m:IModel = getModel();			m.removeEventListener(GraphNodeEvent.NODE_ADDED, onNodeAdded);			m.removeEventListener(GraphNodeEvent.NODE_REMOVED, onNodeRemoved);			m.removeEventListener(GraphEdgeEvent.EDGE_ADDED, onEdgeAdded);			m.removeEventListener(GraphEdgeEvent.EDGE_REMOVED, onEdgeRemoved);						var i:DisplayObject;			while( numChildren > 0 )			{				i = getChildAt(numChildren-1);				var n:NodeSprite = i as NodeSprite;				if (null != n)				{					n.destroy();				}				removeChild(i);			}						super.destroy();		}		private function onNodeRemoved(event:GraphNodeEvent) :void		{			var n:NodeSprite;			for( var i:uint = 0; i < numChildren; i++)			{				n = getChildAt(i) as NodeSprite;				if (null != n)				{					if (event.node == n.node)					{						n.destroy();						removeChild(n);						break;					}				}			}			onChange();		}				private function onEdgeAdded( event:GraphEdgeEvent) :void		{			onChange();		}				private function onEdgeRemoved( event:GraphEdgeEvent) :void		{			onChange();		}				private function onChange() :void		{		}				private function onUpdate(event:UpdateEvent) :void		{			var m:GraphModel = getModel() as GraphModel;						// update ideal positions			var ns1:NodeSprite;			var ns2:NodeSprite;			var vectorBetween:Vector2D;						for (var i:uint=0; i < numChildren; i++)			{				for (var j:uint=0; j < numChildren; j++)				{					ns1 = getChildAt(i) as NodeSprite;					ns2 = getChildAt(j) as NodeSprite;										if (ns1 == ns2)					{						break;					}										vectorBetween = new Vector2D(ns2.x, ns2.y);					vectorBetween.subtract(ns1);										if (Vector2D.isZeroVector(vectorBetween))					{						// add a small random value						vectorBetween.x = RNG.random() - .5;						vectorBetween.y = RNG.random() - .5;					}										// nodes repel each other					//var repel:Number = Math.max( 0, 50 - vectorBetween.length );					var repel:Number = 50 - vectorBetween.length;					vectorBetween.length = Math.abs(repel/2);					ns1.speed.add( vectorBetween );					ns2.speed.add( vectorBetween.reversed() );				}			}						for (i=0; i < numChildren; i++)			{				ns1 = getChildAt(i) as NodeSprite;								ns1.speed.length = Math.min( ns1.speed.length, 50 );								ns1.x += ns1.speed.x;				ns1.y += ns1.speed.y;								ns1.speed.multiply(.99);			}			//			for each (var n1:Node in m.graph.nodes)//			{//				for each (var n2:Node in m.graph.nodes)//				{//					if (n1 == n2)//					{//						break;//					}//					ns1 = getSprite(n1);//					ns2 = getSprite(n2);//					//					vectorBetween = ns2.idealPosition.subtracted(ns1.idealPosition);//					//					if (Vector2D.isZeroVector(vectorBetween))//					{//						vectorBetween.x = RNG.random() - .5;//						vectorBetween.y = RNG.random() - .5;//					}//					//					// nodes want to be 50 pixels from each other//					if (vectorBetween.length > 50)//					{//						// move closer//						vectorBetween.length = 50;//					}//					else//					{//						// move apart//						vectorBetween.length = 50;//						vectorBetween.reverse();//					}//					ns1.idealPosition.add(vectorBetween);//		////					if (m.graph.areConnected(n1, n2))////					{////						// connected nodes want to be 50 pixels from each other	////						var str:Number = 50 - vectorBetween.length;////						if (str > 0)////						{////							vectorBetween.length = str;////							//log.info("movement is to: %s", vectorBetween);////							ns1.idealPosition.add(vectorBetween);////						}////					}////					else////					{////						// unconnected nodes want to be at least 5 pixels from each other////					}//				}//				// no node wants to be off screen//			}//			//			for (var i:uint=0; i < numChildren; i++)//			{//				var ns:NodeSprite = getChildAt(i) as NodeSprite;//				vectorBetween = ns.idealPosition.subtracted(ns);//				vectorBetween.multiply(.1);//				ns.x += vectorBetween.x;//				ns.y += vectorBetween.y;////				////				if (vectorBetween.length < .05)////				{////					break;////				}////				////				var speed:Vector2D = vectorBetween.multiplied(.1);////				ns.x += speed.x;////				ns.y += speed.y;//			}			//			// draw edges//			graphics.clear();//			//			var edges:Vector.<Edge> = m.graph.edges;//			for each (var edge:Edge in edges)//			{//				ns1 = getSprite(edge.to);//				ns2 = getSprite(edge.from);//				//				graphics.lineStyle(2, 0x00ff00);//				graphics.moveTo( ns1.x, ns1.y);//				graphics.lineTo( ns2.x, ns2.y );//			}		}				private function getSprite(node:Node) :NodeSprite		{			for (var i:uint=0; i < numChildren; i++)			{				var ns:NodeSprite = getChildAt(i) as NodeSprite;				if (ns.node == node)				{					return ns;				}			}			return null;			}	}}