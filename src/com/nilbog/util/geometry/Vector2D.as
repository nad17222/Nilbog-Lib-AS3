package com.nilbog.util.geometry {	import com.nilbog.util.number.epsilonCompare;	import uk.co.bigroom.utils.ObjectPool;	import com.nilbog.assertions.checkArgument;	import com.nilbog.dbc.postcondition;	import com.nilbog.dbc.precondition;	import com.nilbog.util.IClonable;	import com.nilbog.util.IComparable;	import com.nilbog.util.string.sprintf;	import flash.geom.Point;	/**	 * @author markhawley	 * 	 * A two-dimensional vector.	 * 	 * Many of the methods of Vector2D come in a 'past-tense' version -- these	 * return a new Vector2D while the 'present-tense' versions alter the	 * vector in-place. (a.multiply(s) multiplies a by a given scalar, but	 * a.multiplied(s) returns a new Vector2D equivalent to this vector multiplied	 * by the given scalar.	 */	public class Vector2D implements IClonable, IComparable	{		internal const p:Point = new Point();				public function get x() :Number		{			return p.x;		}		public function set x(v:Number) :void		{			p.x = v;		}				public function get y() :Number		{			return p.y;		}		public function set y(v:Number) :void		{			p.y = v;		}				/**		 * Returns true if the given vector has zero length.		 * 		 * @param	v	*		 * 		 * @return	Boolean		 */		public static function isZeroVector( v:* ) :Boolean		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						var p:Point = new Point(v.x, v.y);			return p.length == 0;		}				/**		 * Constructor		 * 		 * @param	x	Number		 * @param	y	Number		 */		public function Vector2D( x:Number=0, y:Number=0 )		{			p.x = x;			p.y = y;		}				/**		 * Return angle from x-axis in radians		 * 		 * @param	Number		 */		public function get angle() :Number		{			return Math.atan2(p.y, p.x);		}				/**		 * Sets the angle in radians.		 * 		 * @param	a	Number in radians.		 */		public function set angle( a:Number ) :void		{			var l:Number = p.length;						p.x = l * Math.cos(a);			p.y = l * Math.sin(a);		}				/**		 * Returns the distance from the origin.		 * 		 * @return Number		 */		public function get length() :Number		{			return p.length;		}				/**		 * Sets the distance from the origin, maintaining the current angle.		 * 		 * @param	s	Number		 */		public function set length( s:Number ) :void		{			normalize();			multiply(s);		}				/**		 * Returns a copy of this vector.		 * 		 * @return	Vector2D		 */		public function clone() :IClonable		{			return new Vector2D(p.x, p.y);		}				/**		 * Returns a normalized copy of this vector.		 * 		 * @return	Vector2D		 */		public function normalized() :Vector2D		{			var c:Vector2D = clone() as Vector2D;			c.normalize();			return c;		}				/**		 * Normalizes this vector. Zero vectors are unaffected.		 */		public function normalize() :void		{			p.normalize(1);						postcondition(epsilonCompare(0, length) || epsilonCompare(1, length));		}				/**		 * Returns a copy of this vector reflected about a given vector.		 * 		 * @param	v	*		 * 		 * @return Vector2D		 */		public function reflected( v:* ) :Vector2D		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						var c:Vector2D = clone() as Vector2D;			c.reflect(v);			return c;		}				/**		 * Reflects this vector about a given vector.		 * 		 * @param	v	*		 */		public function reflect( v:* ) :void		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						var r:Vector2D = new Vector2D( v.y, -v.x );			var a:Number = 2 * angleTo(v);			if (0 >= Math.cos(r.angle))			{				a *= -1;			}			rotate(a);		}				/**		 * Returns a copy of this vector, reversed.		 * 		 * @return Vector2D		 */		public function reversed() :Vector2D		{			var c:Vector2D = clone() as Vector2D;			c.reverse();			return c;		}				/**		 * Reverses the direction of this vector.		 */		public function reverse() :void		{			multiply(-1);		}				/**		 * Returns a copy of this vector added to a given one.		 * 		 * @param	v	* (anything with an x and a y)		 * 		 * @return	Vector2D		 */		public function added( v:* ) :Vector2D		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						var c:Vector2D = clone() as Vector2D;			c.add(v);			return c;		}				/**		 * Adds a vector to the current Vector.		 * 		 * @param	v	* anything with an x and a y		 */		public function add( v:* ) :void		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						p.x += v.x;			p.y += v.y;		}				public function subtract( v:* ) :void		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						p.x -= v.x;			p.y -= v.y;		}				public function subtracted( v:* ) :Vector2D		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						var c:Vector2D = clone() as Vector2D;			c.subtract(v);			return c;		}				/**		 * Returns a copy of this vector rotated a given amount.		 * 		 * @param	a	Number, rotation in radians.		 * 		 * @return	Vector2D		 */		public function rotated( a:Number ) :Vector2D		{			var c:Vector2D = clone() as Vector2D;			c.rotate( a );			return c;		}				/**		 * Rotates this vector a given amount.		 * 		 * @param	a	Number, rotation in radians		 */		public function rotate( a:Number ) :void		{			var x1:Number = Math.cos( a ) * p.x - Math.sin( a ) * p.y;			var y1:Number = Math.sin( a ) * p.x + Math.cos( a ) * p.y;			p.x = x1;			p.y = y1;		}				/**		 * Returns a copy of this vector multiplied by a scalar.		 * 		 * @param	s	Number		 * 		 * @return Vector2D		 */		public function multiplied( s:Number ) :Vector2D		{			var c:Vector2D = clone() as Vector2D;			c.multiply(s);			return c;		}				/**		 * Multiplies the vector by a scalar.		 * 		 * @param	s	Number		 */		public function multiply( s:Number ) :void		{			p.x *= s;			p.y *= s;		}				/**		 * Returns the dot product of this vector and another vector.		 * 		 * @param	v	*		 * 		 * @return	Number		 */		public function dotProduct( v:* ) :Number		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						return (p.x * v.x) + (p.y * v.y);		}				/**		 * Returns the cross product of this vector and another vector.		 * 		 * @param v	*		 * 		 * @return	Number		 */		public function crossProduct( v:* ) :Number		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						return (p.x * v.y) - (p.y * v.x); 		}				/**		 * Returns the angle from this vector to another vector.		 * 		 * @param	v	*		 * 		 * @return	Number, angle in radians		 */		public function angleTo( v:* ) :Number		{			checkArgument(v.x is Number && v.y is Number && !isNaN(v.x) && !isNaN(v.y));						var o:Point = new Point(v.x - p.x, v.y - p.x);			return Math.atan2(o.y, o.x);		}		/**		 * Simple string dump.		 * 		 * @return String		 */		public function toString() :String		{			var s:String = sprintf("[Vector2D (%s, %sº)]", p.length, radiansToDegrees(Math.atan2(p.y, p.x)));			return s;		}				public function equals(obj:IComparable):Boolean		{			if (this == obj || this == obj.valueOf())			{				return true;			}			else			{				var v:Vector2D = obj as Vector2D;				null == v ? v = getVector2DFromIComparable(obj) : 1;				return p.equals(v.p);			}		}				public function lessThan(obj:IComparable):Boolean		{			// true if length smaller. tied length, smaller angle			if (this == obj || this == obj.valueOf())			{				return false;			}			else			{				var v:Vector2D = obj as Vector2D;				null == v ? v = getVector2DFromIComparable(obj) : 1;				if (p.length != v.length)				{					return p.length < v.length;				}				else				{					return angle < v.angle;				}			}		}				public function greaterThan(obj:IComparable):Boolean		{			// true if length smaller. tied length, smaller angle			if (this == obj || this == obj.valueOf())			{				return false;			}			else			{				var v:Vector2D = obj as Vector2D;				null == v ? v = getVector2DFromIComparable(obj) : 1;				if (p.length != v.length)				{					return p.length > v.length;				}				else				{					return angle > v.angle;				}			}		}				public function valueOf():Object		{			var c:Point = new Point(p.x, p.y);			return c;		}				private function getVector2DFromIComparable(obj:IComparable) :Vector2D		{			var o:* = obj;			var v:Vector2D;						try			{				v = new Vector2D(o.x, o.y);			}			catch( e:Error )			{				o = obj.valueOf();				try				{					v = new Vector2D(o.x, o.y);				}				catch( e:Error )				{				}			}						return v;		}	}}